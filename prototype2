import numpy as np
import pandas as pd
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from pymoo.operators.sampling.rnd import IntegerRandomSampling
from pymoo.optimize import minimize
from pymoo.visualization.scatter import Scatter
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics.pairwise import euclidean_distances
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

class CoreHunterProblem(Problem):
  def __init__(self, genotype_data, phenotype_data, core_size):
    self.genotype_data = genotype_data
    self.phenotype_data = phenotype_data
    self.core_size = core_size
    self.total_accessions = genotype_data.shape[0]
    
    # 准备数据
    self.combined_data = self._prepare_data()
    
    # 计算距离矩阵（使用Modified Rogers距离）
    self.distance_matrix = self._calculate_modified_rogers_distance()
    
    super().__init__(
      n_var=self.total_accessions,
      n_obj=2,
      n_constr=1,
      xl=0,
      xu=1,
      vtype=int
    )

  def _prepare_data(self):
    # 处理缺失值
    genotype_clean = np.nan_to_num(self.genotype_data, nan=0.0)
    phenotype_clean = np.nan_to_num(self.phenotype_data, nan=0.0)
    
    # 标准化表型数据
    scaler = StandardScaler()
    phenotype_scaled = scaler.fit_transform(phenotype_clean)
    
    # 返回处理后的数据
    return {
      'genotype': genotype_clean,
      'phenotype': phenotype_scaled
    }

  def _calculate_modified_rogers_distance(self):
    n = self.total_accessions
    dist_matrix = np.zeros((n, n))
    genotype_data = self.combined_data['genotype']
    
    # 对于每对材料计算Modified Rogers距离
    for i in range(n):
      for j in range(i, n):
        if i == j:
          dist_matrix[i, j] = 0.0
        else:
          # 计算等位基因频率差异
          diff = genotype_data[i] - genotype_data[j]
          # Modified Rogers距离公式
          mr_dist = np.sqrt(np.sum(diff**2) / (2 * genotype_data.shape[1]))
          dist_matrix[i, j] = mr_dist
          dist_matrix[j, i] = mr_dist
    
    return dist_matrix

  def _evaluate(self, X, out, *args, **kwargs):
    """评估种群中每个解的目标函数"""
    n_individuals = X.shape[0]
    f1 = np.zeros(n_individuals)  # 平均材料到最近核心材料距离
    f2 = np.zeros(n_individuals)  # 平均核心材料间最近距离
    g = np.zeros(n_individuals)   # 约束：核心集合大小必须准确
    
    for i in range(n_individuals):
      # 获取选中的材料（核心种质集合）
      selected_indices = np.where(X[i] == 1)[0]
      n_selected = len(selected_indices)
      
      # 约束：核心集合大小必须准确
      g[i] = abs(n_selected - self.core_size)
      
      if n_selected == 0:
        f1[i] = 0
        f2[i] = 0
        continue
      
      # 计算平均材料到最近核心材料距离
      min_distances = []
      for j in range(self.total_accessions):
        if j in selected_indices:
          continue  # 跳过已经在核心集合中的材料
        if len(selected_indices) > 0:
          min_dist = np.min(self.distance_matrix[j, selected_indices])
          min_distances.append(min_dist)
      
      if min_distances:
        f1[i] = np.mean(min_distances)
      else:
        f1[i] = 0
      
      # 计算核心集合内平均最近材料距离
      if n_selected > 1:
        core_distances = self.distance_matrix[np.ix_(selected_indices, selected_indices)]
        np.fill_diagonal(core_distances, np.inf)  # 忽略自身距离
        nearest_distances = np.min(core_distances, axis=1)
        f2[i] = np.mean(nearest_distances)
      else:
        f2[i] = 0
    
    # 最大化两个距离，所以使用负值进行最小化
    out["F"] = np.column_stack([-f1, -f2])
    out["G"] = g.reshape(-1, 1)

def load_data(genotype_file, phenotype_file):
  """从Excel文件加载基因型和表型数据"""
  # 加载基因型数据
  genotype_df = pd.read_excel(genotype_file)
  # 假设第一列是材料名称/ID
  accession_names = genotype_df.iloc[:, 0].values
  genotype_data = genotype_df.iloc[:, 1:].values
  
  # 加载表型数据
  phenotype_df = pd.read_excel(phenotype_file)
  # 确保材料顺序一致
  phenotype_data = phenotype_df.set_index(phenotype_df.columns[0]).loc[accession_names].values
  
  return genotype_data, phenotype_data, accession_names

def run_corehunter(genotype_file, phenotype_file, core_size_ratio=0.2, pop_size=100, n_gen=200):
  """
  运行CoreHunter优化
  
  参数:
  genotype_file: 基因型Excel文件路径
  phenotype_file: 表型Excel文件路径
  core_size_ratio: 核心种质集合比例
  pop_size: NSGA-II种群大小
  n_gen: 迭代代数
  """
  
  # 加载数据
  print("正在加载数据...")
  genotype_data, phenotype_data, accession_names = load_data(genotype_file, phenotype_file)
  total_accessions = genotype_data.shape[0]
  core_size = int(total_accessions * core_size_ratio)
  
  print(f"总材料数: {total_accessions}")
  print(f"核心集合大小: {core_size}")
  print(f"基因型特征数: {genotype_data.shape[1]}")
  print(f"表型特征数: {phenotype_data.shape[1]}")
  
  # 创建问题实例
  problem = CoreHunterProblem(genotype_data, phenotype_data, core_size)
  
  # 配置NSGA-II算法
  algorithm = NSGA2(
    pop_size=pop_size,
    sampling=IntegerRandomSampling(),
    crossover=SBX(prob=0.9, eta=15),
    mutation=PM(prob=1.0, eta=20),
    eliminate_duplicates=True
  )
  
  # 运行优化
  print("正在运行优化...")
  res = minimize(
    problem,
    algorithm,
    ('n_gen', n_gen),
    seed=42,
    verbose=True
  )
  
  # 分析结果
  print("\n优化完成!")
  print(f"非支配解数量: {len(res.F)}")
  
  return res, accession_names, core_size

def analyze_results(res, accession_names, core_size):
  """分析和显示优化结果"""
  
  # 绘制帕累托前沿
  plt.figure(figsize=(10, 6))
  plt.scatter(-res.F[:, 0], -res.F[:, 1], c='blue', alpha=0.7, s=50)
  plt.xlabel('平均材料到最近核心材料距离')
  plt.ylabel('平均核心材料间最近距离')
  plt.title('帕累托前沿: Core Hunter优化')
  plt.grid(True, alpha=0.3)
  plt.tight_layout()
  plt.show()
  
  # 寻找膝点（折衷解）
  from pymoo.decomposition.asf import ASF
  weights = np.array([0.5, 0.5])  # 两个目标函数的相等权重
  asf = ASF()
  i = asf.do(-res.F, weights).argmin()
  
  # 获取最佳折衷解
  best_solution = res.X[i]
  selected_indices = np.where(best_solution == 1)[0]
  selected_accessions = accession_names[selected_indices]
  
  print(f"\n最佳折衷解（膝点）:")
  print(f"平均材料到最近核心材料距离: {-res.F[i, 0]:.4f}")
  print(f"平均核心材料间最近距离: {-res.F[i, 1]:.4f}")
  print(f"选中 {len(selected_accessions)} 个材料:")
  
  # 显示选中的材料
  for idx, acc in enumerate(selected_accessions):
    print(f"{idx+1}. {acc}")
  
  return selected_accessions, best_solution

def save_results(selected_accessions, output_file):
  """保存选中材料到文件"""
  df = pd.DataFrame({
    '材料ID': selected_accessions,
    '是否选中': True
  })
  df.to_excel(output_file, index=False)
  print(f"\n结果已保存到 {output_file}")

# 示例用法
if __name__ == "__main__":
  # 替换为实际文件路径
  genotype_file = "genotype_data.xlsx"
  phenotype_file = "phenotype_data.xlsx"
  output_file = "core_collection_results.xlsx"
  
  try:
    # 运行CoreHunter优化
    res, accession_names, core_size = run_corehunter(
      genotype_file=genotype_file,
      phenotype_file=phenotype_file,
      core_size_ratio=0.2,  # 20%的材料进入核心集合
      pop_size=100,
      n_gen=200
    )
    
    # 分析和显示结果
    selected_accessions, best_solution = analyze_results(res, accession_names, core_size)
    
    # 保存结果
    save_results(selected_accessions, output_file)
    
  except FileNotFoundError as e:
    print(f"错误: {e}")
    print("请确保基因型和表型Excel文件存在。")
    print("正在创建示例数据文件用于演示...")
    
    # 创建示例数据用于演示
    np.random.seed(42)
    n_accessions = 100
    n_genotype_markers = 50
    n_phenotype_traits = 5
    
    # 生成示例基因型数据（二进制标记）
    genotype_data = np.random.randint(0, 3, (n_accessions, n_genotype_markers))
    accession_names = [f"材料_{i:03d}" for i in range(n_accessions)]
    
    genotype_df = pd.DataFrame(genotype_data)
    genotype_df.insert(0, '材料ID', accession_names)
    genotype_df.to_excel("示例基因型数据.xlsx", index=False)
    
    # 生成示例表型数据
    phenotype_data = np.random.normal(0, 1, (n_accessions, n_phenotype_traits))
    phenotype_df = pd.DataFrame(phenotype_data)
    phenotype_df.insert(0, '材料ID', accession_names)
    phenotype_df.to_excel("示例表型数据.xlsx", index=False)
    
    print("已创建示例文件: 示例基因型数据.xlsx, 示例表型数据.xlsx")
    print("请使用这些文件重新运行脚本。")
  
  
